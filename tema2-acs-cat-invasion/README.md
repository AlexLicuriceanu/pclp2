# Tema 2 PCLP2 (IOCLA) - ACS Cat Invasion
```
TASK 1 SCORE: 10.00/10.00
TASK 3 SCORE: 25.00/25.00
TASK 4 SCORE: 30.00/30.00
README:       10.00/10.00
-------------------------
TOTAL:        75.00/100.00
```

# Task 1 - Caesar Cipher
Folosind `LODSB`, `STOSB` si `MOVSB` am copia bytii din `ESI` in `EDI` si pentru fiecare litera din `ESI` am pornit in `EBX` un contor care merge pana la `EDX` (step). In `caesar_loop` se incrementeaza registrul in care este retinuta litera, `AL`, de `EBX` ori, dupa fiecare incrementare se compara `AL` cu 'Z', daca acesta depaseste litera 'Z', se reseteaza `AL` cu 'A' si se trece la urmatorul pas al buclei.

# Task 3 - Beaufort Cipher
Salvam in variabila `plain_len` valoarea din registrul `ECX`, eliberam registrul `EAX` care este ocupat de tabula recta, iar iterand peste plaintext, in `AH` salvam primul byte din plaintext la care pointeaza `EBX`, iar in `AL` salvam primul byte la care pointeaza `ESI`, care reprezinta cheia. Se compara `AL` cu `AH` (cheia cu litera din plaintext), daca valoarea cheii este mai mare decat litera se sare la label-ul gr (greater), unde litera corespunzatoare din tabula recta este calculata in `EBX` folosind formula `'A' + litera_cheie - litera_plain`, daca valoarea cheii este mai mica decat litera, se sare la label-ul lw (lower), care calculeaza criptarea in `EBX` folosind formula `'Z' - litera_plain + litera_cheie + 1`. Daca litera si cheia au valori ASCII egale, peste `EBX` se scrie 'A'. Dupa ce sunt efectuate operatiile pe litera, se sare la label-ul cont (continue), se incrementeaza pointerul `EDI` si se compara cu 0x0 (NULL) ca sa se verifice daca am ajuns la finalul cheii. In caz afirmativ, se sare la label-ul reset_key, care decrementeaza pointerul `EDI` cu `EDX` pozitii, astfel `EDI` pointeaza catre inceputul cheii. Se incrementeaza pointerul catre plaintext si se sare la inceputul buclei. Pentru a copia bytii literelor din sirului encriptat, se face xor pe `ECX` si `EDX`, in `ECX` se copiaza lungimea sirului encriptat (evident, coincide cu lungimea plaintext), iar de la pointerul `EBX`, care in urma buclei plain_loop pointeaza catre terminatorul de sir al sirului criptat, se scade lungimea sa, astfel `EBX` pointeaza la inceputul sirului criptat. Bucla copy_bytes cicleaza de `EDX` ori si copiaza fiecare caracter al sirului criptat in `EBX` la pozitia corespunzatoare in sirul `ESI`.

# Task 4 - Spiral Cipher
Incepem prin a salva textul in plain in variabila `plain` si lungimea unei linii a matricei in variabila `line_size`. Pentru a calcula lungimea sirului care trebuie criptat, inmultim valoarea `line_size` cu ea insasi si o salvam in variabila `plain_size`. Folosind `LODSB`, `STOSB` si `MOVSB` se copiaza sirul in plaintext din `ESI` in registrul `EDI`. Deoarece in urma acestor operatii pointerul `EDI` pointeaza catre finalul sirului plain, din `EDI` scadem lungimea sirului. In variabilele `top` si `left` am pus 0, iar in `bottom` si `right` am pus valoarea de la `line_size - 1`. Aceste patru variabile reprezinta offseturi de la/pana la care se vor parcurge bucati din matrice. In variabila `direction` am pus valoarea 1 (1 = parcurgere de la stanga la dreapta, 2 = sus jos, 3 = dreapta stanga, 4 = jos sus), iar registrii `EAX`, `ECX` si `EDX` sunt eliberati. Bucla string_loop va cicla pana cand `top` > `bottom` si `left` > `right`, practic pana cand nu mai exista elemente pe care nu le-am vizitat in matrice. Urmeaza apoi patru check-uri in functie de valoarea din variabila `direction`. Daca in `direction` se afla valoarea 1, se parcurg de la stanga la dreapta elementele aflate la pozitia (top, EAX), unde `EAX` ia valori de la offseturile din variabilele `left` si `right`. Pozitia fiecarui element in acest tip de parcurgere este calculata folosind formula `matrice + (line_size * top + EAX) * 4`. Pentru fiecare element parcurs se incrementeaza valoarea caracterului de la pointerul `EDI` cu valoarea gasita matrice si se incrementeaza pointerul `EDI`. Dupa terminarea buclei for_left_right se incrementeaza valoarea din `top` si in `direction` se scrie valoarea 2. Programul repeta in mare parte pasii pentru fiecare directie, insa cu mici diferente. 
* Pentru parcurgerea de sus in jos formula devine `matrice + (line_size * EAX + right) * 4`, unde `EAX` ia valori de la `top` la `bottom`, iar la final variabila `right` este decrementata si directia este setata cu 3. 
* Pentru parcurgerea de la dreapta la stanga, formula pentru a gasi elementele in spirala este `matrice + (line_size * bottom + EAX)`, unde `EAX` ia valori de la `right` la `left`, iar la final `bottom` este decrementat si directia este setata cu 4. 
* Pentru parcurgerea de sus in jos, formula devine `matrice + (line_size * EAX + left)`, unde `EAX` ia valori de la `bottom` la `top`, iar in final este incrementata variabila `left` si directia este setata cu 1. Procesul se repeta pana cand nu mai exista elemente care nu au fost vizitate in matrice.
